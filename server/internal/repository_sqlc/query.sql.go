// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package sqlc_repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addPokerAdmin = `-- name: AddPokerAdmin :one
INSERT INTO poker_admins (user_id, poker_id)
VALUES ($1, $2)
ON CONFLICT (user_id, poker_id)
DO UPDATE SET
    user_id = EXCLUDED.user_id,
    poker_id = EXCLUDED.poker_id
RETURNING user_id, poker_id
`

type AddPokerAdminParams struct {
	UserID  int64
	PokerID pgtype.UUID
}

func (q *Queries) AddPokerAdmin(ctx context.Context, arg *AddPokerAdminParams) (*PokerAdmin, error) {
	row := q.db.QueryRow(ctx, addPokerAdmin, arg.UserID, arg.PokerID)
	var i PokerAdmin
	err := row.Scan(&i.UserID, &i.PokerID)
	return &i, err
}

const addPokerUser = `-- name: AddPokerUser :one
INSERT INTO poker_users (user_id, poker_id, last_date)
VALUES ($1, $2, CURRENT_TIMESTAMP)
ON CONFLICT (user_id, poker_id)
DO UPDATE SET
    user_id = EXCLUDED.user_id,
    poker_id = EXCLUDED.poker_id,
    last_date = CURRENT_TIMESTAMP
RETURNING user_id, poker_id, last_date
`

type AddPokerUserParams struct {
	UserID  int64
	PokerID pgtype.UUID
}

func (q *Queries) AddPokerUser(ctx context.Context, arg *AddPokerUserParams) (*PokerUser, error) {
	row := q.db.QueryRow(ctx, addPokerUser, arg.UserID, arg.PokerID)
	var i PokerUser
	err := row.Scan(&i.UserID, &i.PokerID, &i.LastDate)
	return &i, err
}

const addTask = `-- name: AddTask :one
INSERT INTO tasks (poker_id, title, description, story_point, status, completed, estimate)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING tasks_id, poker_id, title, description, story_point, status, completed, estimate
`

type AddTaskParams struct {
	PokerID     pgtype.UUID
	Title       string
	Description *string
	StoryPoint  *int32
	Status      string
	Completed   bool
	Estimate    *int32
}

func (q *Queries) AddTask(ctx context.Context, arg *AddTaskParams) (*Task, error) {
	row := q.db.QueryRow(ctx, addTask,
		arg.PokerID,
		arg.Title,
		arg.Description,
		arg.StoryPoint,
		arg.Status,
		arg.Completed,
		arg.Estimate,
	)
	var i Task
	err := row.Scan(
		&i.TasksID,
		&i.PokerID,
		&i.Title,
		&i.Description,
		&i.StoryPoint,
		&i.Status,
		&i.Completed,
		&i.Estimate,
	)
	return &i, err
}

const addUserAuthProviders = `-- name: AddUserAuthProviders :one
INSERT INTO user_auth_providers (user_id, provider_uid, provider, name)
VALUES ($1, $2, $3, $4)
returning user_id, provider_uid, provider, name
`

type AddUserAuthProvidersParams struct {
	UserID      int64
	ProviderUid string
	Provider    string
	Name        *string
}

func (q *Queries) AddUserAuthProviders(ctx context.Context, arg *AddUserAuthProvidersParams) (*UserAuthProvider, error) {
	row := q.db.QueryRow(ctx, addUserAuthProviders,
		arg.UserID,
		arg.ProviderUid,
		arg.Provider,
		arg.Name,
	)
	var i UserAuthProvider
	err := row.Scan(
		&i.UserID,
		&i.ProviderUid,
		&i.Provider,
		&i.Name,
	)
	return &i, err
}

const addVoting = `-- name: AddVoting :one
INSERT INTO voting (poker_id, task_id, user_id, estimate)
VALUES ($1, $2, $3, $4)
ON CONFLICT (poker_id, task_id, user_id)
DO UPDATE SET
    user_id = EXCLUDED.user_id,
    poker_id = EXCLUDED.poker_id,
    task_id = EXCLUDED.task_id,
    estimate = EXCLUDED.estimate   
RETURNING user_id, poker_id, task_id, estimate
`

type AddVotingParams struct {
	PokerID  pgtype.UUID
	TaskID   int64
	UserID   int64
	Estimate int32
}

func (q *Queries) AddVoting(ctx context.Context, arg *AddVotingParams) (*Voting, error) {
	row := q.db.QueryRow(ctx, addVoting,
		arg.PokerID,
		arg.TaskID,
		arg.UserID,
		arg.Estimate,
	)
	var i Voting
	err := row.Scan(
		&i.UserID,
		&i.PokerID,
		&i.TaskID,
		&i.Estimate,
	)
	return &i, err
}

const clearTasks = `-- name: ClearTasks :exec
DELETE FROM tasks WHERE poker_id = $1
`

func (q *Queries) ClearTasks(ctx context.Context, pokerID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, clearTasks, pokerID)
	return err
}

const clearVote = `-- name: ClearVote :exec
DELETE FROM voting
WHERE poker_id = $1 AND task_id = $2
`

type ClearVoteParams struct {
	PokerID pgtype.UUID
	TaskID  int64
}

func (q *Queries) ClearVote(ctx context.Context, arg *ClearVoteParams) error {
	_, err := q.db.Exec(ctx, clearVote, arg.PokerID, arg.TaskID)
	return err
}

const createComent = `-- name: CreateComent :one
INSERT INTO comments (poker_id, user_id, task_id, text)
VALUES ($1, $2, $3, $4) 
RETURNING comment_id
`

type CreateComentParams struct {
	PokerID pgtype.UUID
	UserID  int64
	TaskID  int64
	Text    string
}

func (q *Queries) CreateComent(ctx context.Context, arg *CreateComentParams) (int64, error) {
	row := q.db.QueryRow(ctx, createComent,
		arg.PokerID,
		arg.UserID,
		arg.TaskID,
		arg.Text,
	)
	var comment_id int64
	err := row.Scan(&comment_id)
	return comment_id, err
}

const createPoker = `-- name: CreatePoker :one
INSERT INTO poker (poker_id, autor, evaluation_strategy, maximum_score, name, task_id)
VALUES ($1, $2, $3, $4, $5, 0)  
RETURNING poker_id, name, autor, evaluation_strategy, maximum_score, task_id, start_date, end_date
`

type CreatePokerParams struct {
	PokerID            pgtype.UUID
	Autor              int64
	EvaluationStrategy string
	MaximumScore       int32
	Name               *string
}

func (q *Queries) CreatePoker(ctx context.Context, arg *CreatePokerParams) (*Poker, error) {
	row := q.db.QueryRow(ctx, createPoker,
		arg.PokerID,
		arg.Autor,
		arg.EvaluationStrategy,
		arg.MaximumScore,
		arg.Name,
	)
	var i Poker
	err := row.Scan(
		&i.PokerID,
		&i.Name,
		&i.Autor,
		&i.EvaluationStrategy,
		&i.MaximumScore,
		&i.TaskID,
		&i.StartDate,
		&i.EndDate,
	)
	return &i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (name)
VALUES ($1)
returning user_id
`

func (q *Queries) CreateUser(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRow(ctx, createUser, name)
	var user_id int64
	err := row.Scan(&user_id)
	return user_id, err
}

const deletePoker = `-- name: DeletePoker :exec
DELETE FROM poker WHERE poker_id = $1
`

func (q *Queries) DeletePoker(ctx context.Context, pokerID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePoker, pokerID)
	return err
}

const deletePokerAdmins = `-- name: DeletePokerAdmins :exec
DELETE FROM poker_admins WHERE poker_id = $1
`

func (q *Queries) DeletePokerAdmins(ctx context.Context, pokerID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePokerAdmins, pokerID)
	return err
}

const deletePokerComments = `-- name: DeletePokerComments :exec
DELETE FROM comments WHERE poker_id = $1
`

func (q *Queries) DeletePokerComments(ctx context.Context, pokerID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePokerComments, pokerID)
	return err
}

const deletePokerTasks = `-- name: DeletePokerTasks :exec
DELETE FROM tasks WHERE poker_id = $1
`

func (q *Queries) DeletePokerTasks(ctx context.Context, pokerID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePokerTasks, pokerID)
	return err
}

const deletePokerUsers = `-- name: DeletePokerUsers :exec
DELETE FROM poker_users WHERE poker_id = $1
`

func (q *Queries) DeletePokerUsers(ctx context.Context, pokerID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePokerUsers, pokerID)
	return err
}

const deletePokerVotings = `-- name: DeletePokerVotings :exec
DELETE FROM voting WHERE poker_id = $1
`

func (q *Queries) DeletePokerVotings(ctx context.Context, pokerID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePokerVotings, pokerID)
	return err
}

const deleteTask = `-- name: DeleteTask :exec
DELETE FROM tasks WHERE poker_id = $1 AND tasks_id = $2
`

type DeleteTaskParams struct {
	PokerID pgtype.UUID
	TasksID int64
}

func (q *Queries) DeleteTask(ctx context.Context, arg *DeleteTaskParams) error {
	_, err := q.db.Exec(ctx, deleteTask, arg.PokerID, arg.TasksID)
	return err
}

const getComments = `-- name: GetComments :many
SELECT comment_id, poker_id, user_id, task_id, text FROM comments
WHERE poker_id = $1 AND task_id = $2
`

type GetCommentsParams struct {
	PokerID pgtype.UUID
	TaskID  int64
}

func (q *Queries) GetComments(ctx context.Context, arg *GetCommentsParams) ([]*Comment, error) {
	rows, err := q.db.Query(ctx, getComments, arg.PokerID, arg.TaskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Comment
	for rows.Next() {
		var i Comment
		if err := rows.Scan(
			&i.CommentID,
			&i.PokerID,
			&i.UserID,
			&i.TaskID,
			&i.Text,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastSession = `-- name: GetLastSession :many
SELECT 
    t1.user_id, 
    t1.poker_id,
    CASE
        WHEN t2.poker_id IS NOT NULL THEN true
        ELSE false
    END AS is_admin,
    t3.name AS poker_name
FROM 
    public.poker_users AS t1
LEFT JOIN 
    public.poker_admins AS t2
    ON t1.poker_id = t2.poker_id
    AND t1.user_id = t2.user_id
JOIN 
    public.poker AS t3
    ON t3.poker_id = t1.poker_id
WHERE 
    t1.user_id = $1
ORDER BY 
    t1.last_date DESC
LIMIT $2 OFFSET $3
`

type GetLastSessionParams struct {
	UserID int64
	Limit  int32
	Offset int32
}

type GetLastSessionRow struct {
	UserID    int64
	PokerID   pgtype.UUID
	IsAdmin   bool
	PokerName *string
}

func (q *Queries) GetLastSession(ctx context.Context, arg *GetLastSessionParams) ([]*GetLastSessionRow, error) {
	rows, err := q.db.Query(ctx, getLastSession, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetLastSessionRow
	for rows.Next() {
		var i GetLastSessionRow
		if err := rows.Scan(
			&i.UserID,
			&i.PokerID,
			&i.IsAdmin,
			&i.PokerName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPoker = `-- name: GetPoker :one
SELECT poker_id, name, autor, evaluation_strategy, maximum_score, task_id, start_date, end_date FROM poker WHERE poker_id = $1
`

func (q *Queries) GetPoker(ctx context.Context, pokerID pgtype.UUID) (*Poker, error) {
	row := q.db.QueryRow(ctx, getPoker, pokerID)
	var i Poker
	err := row.Scan(
		&i.PokerID,
		&i.Name,
		&i.Autor,
		&i.EvaluationStrategy,
		&i.MaximumScore,
		&i.TaskID,
		&i.StartDate,
		&i.EndDate,
	)
	return &i, err
}

const getPokerAdmins = `-- name: GetPokerAdmins :many
SELECT user_id FROM poker_admins
WHERE poker_id = $1
`

func (q *Queries) GetPokerAdmins(ctx context.Context, pokerID pgtype.UUID) ([]int64, error) {
	rows, err := q.db.Query(ctx, getPokerAdmins, pokerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var user_id int64
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTask = `-- name: GetTask :one
SELECT tasks_id, poker_id, title, description, story_point, status, completed, estimate FROM tasks WHERE poker_id = $1 AND tasks_id = $2
`

type GetTaskParams struct {
	PokerID pgtype.UUID
	TasksID int64
}

func (q *Queries) GetTask(ctx context.Context, arg *GetTaskParams) (*Task, error) {
	row := q.db.QueryRow(ctx, getTask, arg.PokerID, arg.TasksID)
	var i Task
	err := row.Scan(
		&i.TasksID,
		&i.PokerID,
		&i.Title,
		&i.Description,
		&i.StoryPoint,
		&i.Status,
		&i.Completed,
		&i.Estimate,
	)
	return &i, err
}

const getTasks = `-- name: GetTasks :many
SELECT tasks_id, poker_id, title, description, story_point, status, completed, estimate FROM tasks WHERE poker_id = $1 ORDER BY tasks_id
`

func (q *Queries) GetTasks(ctx context.Context, pokerID pgtype.UUID) ([]*Task, error) {
	rows, err := q.db.Query(ctx, getTasks, pokerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.TasksID,
			&i.PokerID,
			&i.Title,
			&i.Description,
			&i.StoryPoint,
			&i.Status,
			&i.Completed,
			&i.Estimate,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAuthProvidersByProviderUid = `-- name: GetUserAuthProvidersByProviderUid :one
SELECT user_id, provider_uid, provider, name FROM user_auth_providers
WHERE provider_uid = $1 AND provider = $2
`

type GetUserAuthProvidersByProviderUidParams struct {
	ProviderUid string
	Provider    string
}

func (q *Queries) GetUserAuthProvidersByProviderUid(ctx context.Context, arg *GetUserAuthProvidersByProviderUidParams) (*UserAuthProvider, error) {
	row := q.db.QueryRow(ctx, getUserAuthProvidersByProviderUid, arg.ProviderUid, arg.Provider)
	var i UserAuthProvider
	err := row.Scan(
		&i.UserID,
		&i.ProviderUid,
		&i.Provider,
		&i.Name,
	)
	return &i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT user_id, name, evaluation_strategy, maximum_score FROM users
WHERE user_id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, userID int64) (*User, error) {
	row := q.db.QueryRow(ctx, getUserByID, userID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Name,
		&i.EvaluationStrategy,
		&i.MaximumScore,
	)
	return &i, err
}

const getUserEstimate = `-- name: GetUserEstimate :one
SELECT estimate FROM voting
WHERE poker_id = $1 AND task_id = $2 AND user_id = $3
`

type GetUserEstimateParams struct {
	PokerID pgtype.UUID
	TaskID  int64
	UserID  int64
}

func (q *Queries) GetUserEstimate(ctx context.Context, arg *GetUserEstimateParams) (int32, error) {
	row := q.db.QueryRow(ctx, getUserEstimate, arg.PokerID, arg.TaskID, arg.UserID)
	var estimate int32
	err := row.Scan(&estimate)
	return estimate, err
}

const getUserIDsByPokerID = `-- name: GetUserIDsByPokerID :many
SELECT user_id, poker_id, last_date FROM poker_users
WHERE poker_id = $1
`

func (q *Queries) GetUserIDsByPokerID(ctx context.Context, pokerID pgtype.UUID) ([]*PokerUser, error) {
	rows, err := q.db.Query(ctx, getUserIDsByPokerID, pokerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*PokerUser
	for rows.Next() {
		var i PokerUser
		if err := rows.Scan(&i.UserID, &i.PokerID, &i.LastDate); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByIDs = `-- name: GetUsersByIDs :many
SELECT user_id, name, evaluation_strategy, maximum_score FROM users
WHERE user_id = ANY($1::bigint[])
`

func (q *Queries) GetUsersByIDs(ctx context.Context, dollar_1 []int64) ([]*User, error) {
	rows, err := q.db.Query(ctx, getUsersByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserID,
			&i.Name,
			&i.EvaluationStrategy,
			&i.MaximumScore,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVotingResults = `-- name: GetVotingResults :many
SELECT user_id, estimate FROM voting
WHERE poker_id = $1 AND task_id = $2
`

type GetVotingResultsParams struct {
	PokerID pgtype.UUID
	TaskID  int64
}

type GetVotingResultsRow struct {
	UserID   int64
	Estimate int32
}

func (q *Queries) GetVotingResults(ctx context.Context, arg *GetVotingResultsParams) ([]*GetVotingResultsRow, error) {
	rows, err := q.db.Query(ctx, getVotingResults, arg.PokerID, arg.TaskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetVotingResultsRow
	for rows.Next() {
		var i GetVotingResultsRow
		if err := rows.Scan(&i.UserID, &i.Estimate); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVotingState = `-- name: GetVotingState :one
SELECT task_id, start_date, end_date FROM poker
WHERE poker_id = $1
`

type GetVotingStateRow struct {
	TaskID    *int64
	StartDate pgtype.Timestamp
	EndDate   pgtype.Timestamp
}

func (q *Queries) GetVotingState(ctx context.Context, pokerID pgtype.UUID) (*GetVotingStateRow, error) {
	row := q.db.QueryRow(ctx, getVotingState, pokerID)
	var i GetVotingStateRow
	err := row.Scan(&i.TaskID, &i.StartDate, &i.EndDate)
	return &i, err
}

const removeVote = `-- name: RemoveVote :exec
DELETE FROM voting
WHERE poker_id = $1 AND task_id = $2 AND user_id = $3
`

type RemoveVoteParams struct {
	PokerID pgtype.UUID
	TaskID  int64
	UserID  int64
}

func (q *Queries) RemoveVote(ctx context.Context, arg *RemoveVoteParams) error {
	_, err := q.db.Exec(ctx, removeVote, arg.PokerID, arg.TaskID, arg.UserID)
	return err
}

const updatePokerTaskAndDates = `-- name: UpdatePokerTaskAndDates :exec
UPDATE poker
SET
    task_id = $1,
    start_date = $2,
    end_date = $3
WHERE
    poker_id = $4
`

type UpdatePokerTaskAndDatesParams struct {
	TaskID    *int64
	StartDate pgtype.Timestamp
	EndDate   pgtype.Timestamp
	PokerID   pgtype.UUID
}

func (q *Queries) UpdatePokerTaskAndDates(ctx context.Context, arg *UpdatePokerTaskAndDatesParams) error {
	_, err := q.db.Exec(ctx, updatePokerTaskAndDates,
		arg.TaskID,
		arg.StartDate,
		arg.EndDate,
		arg.PokerID,
	)
	return err
}

const updateTask = `-- name: UpdateTask :one
UPDATE tasks
SET
    title = $3,
    description = $4,
    story_point = $5,
    status = $6,
    completed = $7,
    estimate = $8
WHERE poker_id = $1 AND tasks_id = $2
RETURNING tasks_id, poker_id, title, description, story_point, status, completed, estimate
`

type UpdateTaskParams struct {
	PokerID     pgtype.UUID
	TasksID     int64
	Title       string
	Description *string
	StoryPoint  *int32
	Status      string
	Completed   bool
	Estimate    *int32
}

func (q *Queries) UpdateTask(ctx context.Context, arg *UpdateTaskParams) (*Task, error) {
	row := q.db.QueryRow(ctx, updateTask,
		arg.PokerID,
		arg.TasksID,
		arg.Title,
		arg.Description,
		arg.StoryPoint,
		arg.Status,
		arg.Completed,
		arg.Estimate,
	)
	var i Task
	err := row.Scan(
		&i.TasksID,
		&i.PokerID,
		&i.Title,
		&i.Description,
		&i.StoryPoint,
		&i.Status,
		&i.Completed,
		&i.Estimate,
	)
	return &i, err
}

const updateUserName = `-- name: UpdateUserName :one
UPDATE users
SET name = $1
WHERE user_id = $2
RETURNING user_id, name, evaluation_strategy, maximum_score
`

type UpdateUserNameParams struct {
	Name   string
	UserID int64
}

func (q *Queries) UpdateUserName(ctx context.Context, arg *UpdateUserNameParams) (*User, error) {
	row := q.db.QueryRow(ctx, updateUserName, arg.Name, arg.UserID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Name,
		&i.EvaluationStrategy,
		&i.MaximumScore,
	)
	return &i, err
}

const upsertUserSettings = `-- name: UpsertUserSettings :one
INSERT INTO user_settings (user_id, evaluation_strategy, maximum_score)
VALUES ($1, $2, $3)
ON CONFLICT (user_id)
DO UPDATE SET
    user_id = EXCLUDED.user_id,
    evaluation_strategy = EXCLUDED.evaluation_strategy,
    maximum_score = EXCLUDED.maximum_score
RETURNING user_id, evaluation_strategy, maximum_score
`

type UpsertUserSettingsParams struct {
	UserID             int64
	EvaluationStrategy string
	MaximumScore       int32
}

func (q *Queries) UpsertUserSettings(ctx context.Context, arg *UpsertUserSettingsParams) (*UserSetting, error) {
	row := q.db.QueryRow(ctx, upsertUserSettings, arg.UserID, arg.EvaluationStrategy, arg.MaximumScore)
	var i UserSetting
	err := row.Scan(&i.UserID, &i.EvaluationStrategy, &i.MaximumScore)
	return &i, err
}
