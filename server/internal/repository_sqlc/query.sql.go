// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package sqlc_repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addUserAuthProviders = `-- name: AddUserAuthProviders :one
INSERT INTO user_auth_providers (user_id, provider_uid, provider, name)
VALUES ($1, $2, $3, $4)
returning user_id, provider_uid, provider, name
`

type AddUserAuthProvidersParams struct {
	UserID      int64
	ProviderUid string
	Provider    string
	Name        *string
}

func (q *Queries) AddUserAuthProviders(ctx context.Context, arg *AddUserAuthProvidersParams) (*UserAuthProvider, error) {
	row := q.db.QueryRow(ctx, addUserAuthProviders,
		arg.UserID,
		arg.ProviderUid,
		arg.Provider,
		arg.Name,
	)
	var i UserAuthProvider
	err := row.Scan(
		&i.UserID,
		&i.ProviderUid,
		&i.Provider,
		&i.Name,
	)
	return &i, err
}

const addUserExercise = `-- name: AddUserExercise :exec
INSERT INTO user_exercises (user_id, exercise_id, attempts_count, created_at, updated_at)
VALUES ($1, $2, 0, NOW(), NOW())
ON CONFLICT (user_id, exercise_id) DO NOTHING
`

type AddUserExerciseParams struct {
	UserID     int64
	ExerciseID int64
}

func (q *Queries) AddUserExercise(ctx context.Context, arg *AddUserExerciseParams) error {
	_, err := q.db.Exec(ctx, addUserExercise, arg.UserID, arg.ExerciseID)
	return err
}

const countCategories = `-- name: CountCategories :one
SELECT COUNT(*) FROM categories WHERE user_id = $1 AND is_active = TRUE
`

func (q *Queries) CountCategories(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countCategories, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countCategoriesByLanguage = `-- name: CountCategoriesByLanguage :one
SELECT COUNT(*) FROM categories WHERE user_id = $1 AND programming_language = $2 AND is_active = TRUE
`

type CountCategoriesByLanguageParams struct {
	UserID              int64
	ProgrammingLanguage string
}

func (q *Queries) CountCategoriesByLanguage(ctx context.Context, arg *CountCategoriesByLanguageParams) (int64, error) {
	row := q.db.QueryRow(ctx, countCategoriesByLanguage, arg.UserID, arg.ProgrammingLanguage)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countExercises = `-- name: CountExercises :one
SELECT COUNT(*) FROM exercises WHERE user_id = $1 AND is_active = TRUE
`

func (q *Queries) CountExercises(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countExercises, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countExercisesByCategory = `-- name: CountExercisesByCategory :one
SELECT COUNT(*) FROM exercises WHERE category_id = $1 AND is_active = TRUE
`

func (q *Queries) CountExercisesByCategory(ctx context.Context, categoryID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countExercisesByCategory, categoryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countExercisesFiltered = `-- name: CountExercisesFiltered :one
SELECT COUNT(*) FROM exercises e
WHERE (e.user_id = $1 OR e.is_common = TRUE)
  AND e.is_active = TRUE
  AND ($2::varchar = '' OR e.programming_language = $2)
  AND ($3::bigint = 0 OR e.category_id = $3)
`

type CountExercisesFilteredParams struct {
	UserID  int64
	Column2 string
	Column3 int64
}

// $1: user_id, $2: programming_language, $3: category_id
func (q *Queries) CountExercisesFiltered(ctx context.Context, arg *CountExercisesFilteredParams) (int64, error) {
	row := q.db.QueryRow(ctx, countExercisesFiltered, arg.UserID, arg.Column2, arg.Column3)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserExercises = `-- name: CountUserExercises :one
SELECT COUNT(*) FROM user_exercises WHERE user_id = $1
`

func (q *Queries) CountUserExercises(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countUserExercises, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserExercisesFiltered = `-- name: CountUserExercisesFiltered :one
SELECT COUNT(*) FROM user_exercises ue
    JOIN exercises e ON e.id = ue.exercise_id AND e.is_active = TRUE
 
   JOIN categories c ON c.id = e.category_id
      AND e.is_active = TRUE

WHERE ue.user_id = $1
  AND ($2::varchar = '' OR c.programming_language = $2)
  AND ($3::bigint = 0 OR e.category_id = $3)
`

type CountUserExercisesFilteredParams struct {
	UserID  int64
	Column2 string
	Column3 int64
}

// $1: user_id, $2: programming_language, $3: category_id
func (q *Queries) CountUserExercisesFiltered(ctx context.Context, arg *CountUserExercisesFilteredParams) (int64, error) {
	row := q.db.QueryRow(ctx, countUserExercisesFiltered, arg.UserID, arg.Column2, arg.Column3)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCategory = `-- name: CreateCategory :one
INSERT INTO categories (
    user_id, name, description, programming_language, color, icon, status, created_at, updated_at, is_active
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, NOW(), NOW(), TRUE
) RETURNING id, user_id, name, description, programming_language, color, icon, status, created_at, updated_at, is_active, is_common
`

type CreateCategoryParams struct {
	UserID              int64
	Name                string
	Description         *string
	ProgrammingLanguage string
	Color               *string
	Icon                *string
	Status              *string
}

func (q *Queries) CreateCategory(ctx context.Context, arg *CreateCategoryParams) (*Category, error) {
	row := q.db.QueryRow(ctx, createCategory,
		arg.UserID,
		arg.Name,
		arg.Description,
		arg.ProgrammingLanguage,
		arg.Color,
		arg.Icon,
		arg.Status,
	)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.ProgrammingLanguage,
		&i.Color,
		&i.Icon,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
		&i.IsCommon,
	)
	return &i, err
}

const createExercise = `-- name: CreateExercise :one
INSERT INTO exercises (
    user_id, title, description, category_id, code_to_remember, created_at, updated_at, is_active, programming_language, is_common
) VALUES (
    $1, $2, $3, $4, $5, NOW(), NOW(), TRUE, $6, $7
) RETURNING id, user_id, title, description, category_id, code_to_remember, created_at, updated_at, is_active, programming_language, is_common
`

type CreateExerciseParams struct {
	UserID              int64
	Title               string
	Description         *string
	CategoryID          int64
	CodeToRemember      string
	ProgrammingLanguage string
	IsCommon            *bool
}

type CreateExerciseRow struct {
	ID                  int64
	UserID              int64
	Title               string
	Description         *string
	CategoryID          int64
	CodeToRemember      string
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	IsActive            *bool
	ProgrammingLanguage string
	IsCommon            *bool
}

func (q *Queries) CreateExercise(ctx context.Context, arg *CreateExerciseParams) (*CreateExerciseRow, error) {
	row := q.db.QueryRow(ctx, createExercise,
		arg.UserID,
		arg.Title,
		arg.Description,
		arg.CategoryID,
		arg.CodeToRemember,
		arg.ProgrammingLanguage,
		arg.IsCommon,
	)
	var i CreateExerciseRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.CategoryID,
		&i.CodeToRemember,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
		&i.ProgrammingLanguage,
		&i.IsCommon,
	)
	return &i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (name, is_admin)
VALUES ($1, $2)
returning user_id, name, evaluation_strategy, maximum_score, is_admin
`

type CreateUserParams struct {
	Name    string
	IsAdmin bool
}

func (q *Queries) CreateUser(ctx context.Context, arg *CreateUserParams) (*User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Name, arg.IsAdmin)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Name,
		&i.EvaluationStrategy,
		&i.MaximumScore,
		&i.IsAdmin,
	)
	return &i, err
}

const deleteCategory = `-- name: DeleteCategory :exec
UPDATE categories SET is_active = FALSE 
WHERE id = $1
  AND ($3::boolean OR user_id = $2)
`

type DeleteCategoryParams struct {
	ID      int64
	UserID  int64
	Column3 bool
}

func (q *Queries) DeleteCategory(ctx context.Context, arg *DeleteCategoryParams) error {
	_, err := q.db.Exec(ctx, deleteCategory, arg.ID, arg.UserID, arg.Column3)
	return err
}

const deleteExercise = `-- name: DeleteExercise :exec
UPDATE exercises SET is_active = FALSE
WHERE id = $1
  AND ($3::boolean OR user_id = $2)
`

type DeleteExerciseParams struct {
	ID      int64
	UserID  int64
	Column3 bool
}

func (q *Queries) DeleteExercise(ctx context.Context, arg *DeleteExerciseParams) error {
	_, err := q.db.Exec(ctx, deleteExercise, arg.ID, arg.UserID, arg.Column3)
	return err
}

const getAllUsers = `-- name: GetAllUsers :many
SELECT user_id, name, evaluation_strategy, maximum_score, is_admin FROM users
`

func (q *Queries) GetAllUsers(ctx context.Context) ([]*User, error) {
	rows, err := q.db.Query(ctx, getAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserID,
			&i.Name,
			&i.EvaluationStrategy,
			&i.MaximumScore,
			&i.IsAdmin,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategories = `-- name: GetCategories :many
SELECT c.id, c.user_id, c.name, c.description, c.programming_language, c.color, c.icon, c.status, c.created_at, c.updated_at, c.is_active, c.is_common
FROM categories c
WHERE c.user_id = $1 AND c.is_active = TRUE
ORDER BY c.created_at DESC
`

func (q *Queries) GetCategories(ctx context.Context, userID int64) ([]*Category, error) {
	rows, err := q.db.Query(ctx, getCategories, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.ProgrammingLanguage,
			&i.Color,
			&i.Icon,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsActive,
			&i.IsCommon,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoriesByLanguage = `-- name: GetCategoriesByLanguage :many
SELECT id, user_id, name, description, programming_language, color, icon, status, created_at, updated_at, is_active, is_common FROM categories
WHERE user_id = $1 AND programming_language = $2 AND is_active = TRUE
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetCategoriesByLanguageParams struct {
	UserID              int64
	ProgrammingLanguage string
	Limit               int32
	Offset              int32
}

func (q *Queries) GetCategoriesByLanguage(ctx context.Context, arg *GetCategoriesByLanguageParams) ([]*Category, error) {
	rows, err := q.db.Query(ctx, getCategoriesByLanguage,
		arg.UserID,
		arg.ProgrammingLanguage,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.ProgrammingLanguage,
			&i.Color,
			&i.Icon,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsActive,
			&i.IsCommon,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategory = `-- name: GetCategory :one
SELECT c.id, c.user_id, c.name, c.description, c.programming_language, c.color, c.icon, c.status, c.created_at, c.updated_at, c.is_active, c.is_common
FROM categories c
WHERE c.id = $1 AND c.user_id = $2 AND c.is_active = TRUE
`

type GetCategoryParams struct {
	ID     int64
	UserID int64
}

func (q *Queries) GetCategory(ctx context.Context, arg *GetCategoryParams) (*Category, error) {
	row := q.db.QueryRow(ctx, getCategory, arg.ID, arg.UserID)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.ProgrammingLanguage,
		&i.Color,
		&i.Icon,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
		&i.IsCommon,
	)
	return &i, err
}

const getExercise = `-- name: GetExercise :one
SELECT e.id, e.user_id, e.title, e.description, e.category_id, e.programming_language, e.code_to_remember, e.created_at, e.updated_at, e.is_active, e.is_common
FROM exercises e
WHERE e.id = $1 AND e.is_active = TRUE
`

func (q *Queries) GetExercise(ctx context.Context, id int64) (*Exercise, error) {
	row := q.db.QueryRow(ctx, getExercise, id)
	var i Exercise
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.CategoryID,
		&i.ProgrammingLanguage,
		&i.CodeToRemember,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
		&i.IsCommon,
	)
	return &i, err
}

const getExerciseStat = `-- name: GetExerciseStat :one
SELECT es.user_id, es.exercise_id, es.total_attempts, es.successful_attempts, es.total_typing_time, es.total_typed_chars, es.created_at, es.updated_at
FROM exercise_stats es WHERE es.user_id = $1 AND es.exercise_id = $2
`

type GetExerciseStatParams struct {
	UserID     int64
	ExerciseID int64
}

func (q *Queries) GetExerciseStat(ctx context.Context, arg *GetExerciseStatParams) (*ExerciseStat, error) {
	row := q.db.QueryRow(ctx, getExerciseStat, arg.UserID, arg.ExerciseID)
	var i ExerciseStat
	err := row.Scan(
		&i.UserID,
		&i.ExerciseID,
		&i.TotalAttempts,
		&i.SuccessfulAttempts,
		&i.TotalTypingTime,
		&i.TotalTypedChars,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getExercises = `-- name: GetExercises :many
SELECT e.id, e.user_id, e.title, e.description, e.category_id, e.programming_language, e.code_to_remember, e.created_at, e.updated_at, e.is_active, e.is_common
FROM exercises e
LEFT JOIN user_exercises ue ON ue.exercise_id = e.id AND ue.user_id = $1
WHERE e.user_id = $1 AND e.is_active = TRUE
ORDER BY e.programming_language ASC, e.category_id ASC, e.created_at DESC
LIMIT $2 OFFSET $3
`

type GetExercisesParams struct {
	UserID int64
	Limit  int32
	Offset int32
}

func (q *Queries) GetExercises(ctx context.Context, arg *GetExercisesParams) ([]*Exercise, error) {
	rows, err := q.db.Query(ctx, getExercises, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Exercise
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.CategoryID,
			&i.ProgrammingLanguage,
			&i.CodeToRemember,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsActive,
			&i.IsCommon,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExercisesFiltered = `-- name: GetExercisesFiltered :many
SELECT
  e.id,
  e.user_id,
  e.title,
  e.description,
  e.category_id,
  e.programming_language,
  e.code_to_remember,
  e.created_at,
  e.updated_at,
  e.is_active,
  e.is_common,
  CASE 
    WHEN ue.exercise_id IS NULL THEN 
      FALSE
    ELSE
      TRUE
  END AS is_user_exercise,

  case 
   WHEN es.successful_attempts > 0 THEN 
   TRUE
   ELSE
   FALSE
   END as is_solved 

FROM exercises e
LEFT JOIN user_exercises ue
  ON ue.exercise_id = e.id AND ue.user_id = $1

LEFT JOIN exercise_stats es
  ON es.exercise_id = e.id AND ue.user_id = $1


WHERE
  (e.user_id = $1 OR e.is_common = TRUE)
  AND e.is_active = TRUE
  AND ($2::varchar  = '' OR e.programming_language = $2)
  AND ($3::bigint = 0 OR e.category_id = $3)
ORDER BY
  e.programming_language ASC,
  e.category_id ASC,
  e.created_at DESC
LIMIT $4 OFFSET $5
`

type GetExercisesFilteredParams struct {
	UserID  int64
	Column2 string
	Column3 int64
	Limit   int32
	Offset  int32
}

type GetExercisesFilteredRow struct {
	ID                  int64
	UserID              int64
	Title               string
	Description         *string
	CategoryID          int64
	ProgrammingLanguage string
	CodeToRemember      string
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	IsActive            *bool
	IsCommon            *bool
	IsUserExercise      bool
	IsSolved            bool
}

// $1: user_id, $2: programming_language, $3: category_id, $4: limit, $5: offset
func (q *Queries) GetExercisesFiltered(ctx context.Context, arg *GetExercisesFilteredParams) ([]*GetExercisesFilteredRow, error) {
	rows, err := q.db.Query(ctx, getExercisesFiltered,
		arg.UserID,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetExercisesFilteredRow
	for rows.Next() {
		var i GetExercisesFilteredRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.CategoryID,
			&i.ProgrammingLanguage,
			&i.CodeToRemember,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsActive,
			&i.IsCommon,
			&i.IsUserExercise,
			&i.IsSolved,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAuthProvidersByProviderUid = `-- name: GetUserAuthProvidersByProviderUid :one
SELECT user_id, provider_uid, provider, name FROM user_auth_providers
WHERE provider_uid = $1 AND provider = $2
`

type GetUserAuthProvidersByProviderUidParams struct {
	ProviderUid string
	Provider    string
}

func (q *Queries) GetUserAuthProvidersByProviderUid(ctx context.Context, arg *GetUserAuthProvidersByProviderUidParams) (*UserAuthProvider, error) {
	row := q.db.QueryRow(ctx, getUserAuthProvidersByProviderUid, arg.ProviderUid, arg.Provider)
	var i UserAuthProvider
	err := row.Scan(
		&i.UserID,
		&i.ProviderUid,
		&i.Provider,
		&i.Name,
	)
	return &i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT user_id, name, evaluation_strategy, maximum_score, is_admin FROM users
WHERE user_id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, userID int64) (*User, error) {
	row := q.db.QueryRow(ctx, getUserByID, userID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Name,
		&i.EvaluationStrategy,
		&i.MaximumScore,
		&i.IsAdmin,
	)
	return &i, err
}

const getUserExerciseIDs = `-- name: GetUserExerciseIDs :many
SELECT exercise_id FROM user_exercises WHERE user_id = $1
`

func (q *Queries) GetUserExerciseIDs(ctx context.Context, userID int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, getUserExerciseIDs, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var exercise_id int64
		if err := rows.Scan(&exercise_id); err != nil {
			return nil, err
		}
		items = append(items, exercise_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserExercisesFiltered = `-- name: GetUserExercisesFiltered :many
    SELECT 
        ue.user_id,
        ue.exercise_id,
        ue.completed_at,
        ue.score,
        ue.attempts_count,
   
        e.id as exercise_id,
        e.user_id as exercise_user_id,
        e.title,
        e.description,
        e.category_id,
        c.programming_language,
        e.code_to_remember,
        e.created_at as created_at,
        e.updated_at as updated_at,
        e.is_active,
        e.is_common,
        TRUE AS is_user_exercise,

        CASE WHEN es.successful_attempts > 0 THEN TRUE ELSE FALSE END as is_solved
    FROM user_exercises ue
    JOIN exercises e ON e.id = ue.exercise_id AND e.is_active = TRUE
    JOIN categories c ON c.id = e.category_id AND e.is_active = TRUE
    LEFT JOIN exercise_stats es ON es.exercise_id = e.id AND ue.user_id = $1
    WHERE 
       ue.user_id = $1
      AND ($2::varchar = '' OR c.programming_language = $2)
      AND ($3::bigint = 0 OR e.category_id = $3)
  
ORDER BY c.programming_language ASC, e.category_id ASC, e.created_at DESC
LIMIT $4 OFFSET $5
`

type GetUserExercisesFilteredParams struct {
	UserID  int64
	Column2 string
	Column3 int64
	Limit   int32
	Offset  int32
}

type GetUserExercisesFilteredRow struct {
	UserID              int64
	ExerciseID          int64
	CompletedAt         pgtype.Timestamptz
	Score               *int32
	AttemptsCount       *int32
	ExerciseID_2        int64
	ExerciseUserID      int64
	Title               string
	Description         *string
	CategoryID          int64
	ProgrammingLanguage string
	CodeToRemember      string
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	IsActive            *bool
	IsCommon            *bool
	IsUserExercise      bool
	IsSolved            bool
}

// $1: user_id, $2: programming_language, $3: category_id, $4: limit, $5: offset
func (q *Queries) GetUserExercisesFiltered(ctx context.Context, arg *GetUserExercisesFilteredParams) ([]*GetUserExercisesFilteredRow, error) {
	rows, err := q.db.Query(ctx, getUserExercisesFiltered,
		arg.UserID,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetUserExercisesFilteredRow
	for rows.Next() {
		var i GetUserExercisesFilteredRow
		if err := rows.Scan(
			&i.UserID,
			&i.ExerciseID,
			&i.CompletedAt,
			&i.Score,
			&i.AttemptsCount,
			&i.ExerciseID_2,
			&i.ExerciseUserID,
			&i.Title,
			&i.Description,
			&i.CategoryID,
			&i.ProgrammingLanguage,
			&i.CodeToRemember,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsActive,
			&i.IsCommon,
			&i.IsUserExercise,
			&i.IsSolved,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserStats = `-- name: GetUserStats :one
SELECT
    $1::bigint as user_id,
    COUNT(DISTINCT es.exercise_id) as total_exercises,
    COUNT(DISTINCT CASE WHEN es.successful_attempts > 0 THEN es.exercise_id END) as completed_exercises,
    CASE WHEN SUM(es.total_attempts) > 0
         THEN ROUND(SUM(es.successful_attempts)::numeric / NULLIF(SUM(es.total_attempts),0) * 100)::int
         ELSE 0
    END as average_score,
    COALESCE(SUM(es.total_attempts), 0)::bigint as total_attempts,
    COALESCE(SUM(es.total_typing_time), 0)::bigint as total_time
FROM exercise_stats es
WHERE es.user_id = $1
`

type GetUserStatsRow struct {
	UserID             int64
	TotalExercises     int64
	CompletedExercises int64
	AverageScore       int32
	TotalAttempts      int64
	TotalTime          int64
}

func (q *Queries) GetUserStats(ctx context.Context, dollar_1 int64) (*GetUserStatsRow, error) {
	row := q.db.QueryRow(ctx, getUserStats, dollar_1)
	var i GetUserStatsRow
	err := row.Scan(
		&i.UserID,
		&i.TotalExercises,
		&i.CompletedExercises,
		&i.AverageScore,
		&i.TotalAttempts,
		&i.TotalTime,
	)
	return &i, err
}

const getUsersByIDs = `-- name: GetUsersByIDs :many
SELECT user_id, name, evaluation_strategy, maximum_score, is_admin FROM users
WHERE user_id = ANY($1::bigint[])
`

func (q *Queries) GetUsersByIDs(ctx context.Context, dollar_1 []int64) ([]*User, error) {
	rows, err := q.db.Query(ctx, getUsersByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserID,
			&i.Name,
			&i.EvaluationStrategy,
			&i.MaximumScore,
			&i.IsAdmin,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeUserExercise = `-- name: RemoveUserExercise :exec
DELETE FROM user_exercises 
WHERE user_id = $1 AND exercise_id = $2
`

type RemoveUserExerciseParams struct {
	UserID     int64
	ExerciseID int64
}

func (q *Queries) RemoveUserExercise(ctx context.Context, arg *RemoveUserExerciseParams) error {
	_, err := q.db.Exec(ctx, removeUserExercise, arg.UserID, arg.ExerciseID)
	return err
}

const setUserAdmin = `-- name: SetUserAdmin :one
UPDATE users SET is_admin = $2 WHERE user_id = $1 RETURNING user_id, name, evaluation_strategy, maximum_score, is_admin
`

type SetUserAdminParams struct {
	UserID  int64
	IsAdmin bool
}

func (q *Queries) SetUserAdmin(ctx context.Context, arg *SetUserAdminParams) (*User, error) {
	row := q.db.QueryRow(ctx, setUserAdmin, arg.UserID, arg.IsAdmin)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Name,
		&i.EvaluationStrategy,
		&i.MaximumScore,
		&i.IsAdmin,
	)
	return &i, err
}

const updateCategory = `-- name: UpdateCategory :one
UPDATE categories SET
    name = $1,
    description = $2,
    programming_language = $3,
    color = $4,
    icon = $5,
    status = $6,
    is_common = $7,
    updated_at = NOW()
WHERE id = $8
  AND is_active = TRUE
  AND ($10::boolean OR user_id = $9)
RETURNING id, user_id, name, description, programming_language, color, icon, status, created_at, updated_at, is_active, is_common
`

type UpdateCategoryParams struct {
	Name                string
	Description         *string
	ProgrammingLanguage string
	Color               *string
	Icon                *string
	Status              *string
	IsCommon            *bool
	ID                  int64
	UserID              int64
	Column10            bool
}

func (q *Queries) UpdateCategory(ctx context.Context, arg *UpdateCategoryParams) (*Category, error) {
	row := q.db.QueryRow(ctx, updateCategory,
		arg.Name,
		arg.Description,
		arg.ProgrammingLanguage,
		arg.Color,
		arg.Icon,
		arg.Status,
		arg.IsCommon,
		arg.ID,
		arg.UserID,
		arg.Column10,
	)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.ProgrammingLanguage,
		&i.Color,
		&i.Icon,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
		&i.IsCommon,
	)
	return &i, err
}

const updateExercise = `-- name: UpdateExercise :one
UPDATE exercises SET
    title = $1,
    description = $2,
    category_id = $3,
    code_to_remember = $4,
    updated_at = NOW(),
    programming_language = $5,
    is_common = $6
WHERE id = $7
  AND is_active = TRUE
  AND ($9::boolean OR user_id = $8)
RETURNING id, user_id, title, description, category_id, code_to_remember, created_at, updated_at, is_active, programming_language, is_common
`

type UpdateExerciseParams struct {
	Title               string
	Description         *string
	CategoryID          int64
	CodeToRemember      string
	ProgrammingLanguage string
	IsCommon            *bool
	ID                  int64
	UserID              int64
	Column9             bool
}

type UpdateExerciseRow struct {
	ID                  int64
	UserID              int64
	Title               string
	Description         *string
	CategoryID          int64
	CodeToRemember      string
	CreatedAt           pgtype.Timestamptz
	UpdatedAt           pgtype.Timestamptz
	IsActive            *bool
	ProgrammingLanguage string
	IsCommon            *bool
}

func (q *Queries) UpdateExercise(ctx context.Context, arg *UpdateExerciseParams) (*UpdateExerciseRow, error) {
	row := q.db.QueryRow(ctx, updateExercise,
		arg.Title,
		arg.Description,
		arg.CategoryID,
		arg.CodeToRemember,
		arg.ProgrammingLanguage,
		arg.IsCommon,
		arg.ID,
		arg.UserID,
		arg.Column9,
	)
	var i UpdateExerciseRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.CategoryID,
		&i.CodeToRemember,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
		&i.ProgrammingLanguage,
		&i.IsCommon,
	)
	return &i, err
}

const updateExerciseStat = `-- name: UpdateExerciseStat :one
UPDATE exercise_stats SET
    total_attempts = $3,
    successful_attempts = $4,
    total_typing_time = $5,
    total_typed_chars = $6,
    updated_at = NOW()
WHERE user_id = $1 AND exercise_id = $2
RETURNING  user_id, exercise_id, total_attempts, successful_attempts, total_typing_time, total_typed_chars, created_at, updated_at
`

type UpdateExerciseStatParams struct {
	UserID             int64
	ExerciseID         int64
	TotalAttempts      int32
	SuccessfulAttempts int32
	TotalTypingTime    int64
	TotalTypedChars    int32
}

func (q *Queries) UpdateExerciseStat(ctx context.Context, arg *UpdateExerciseStatParams) (*ExerciseStat, error) {
	row := q.db.QueryRow(ctx, updateExerciseStat,
		arg.UserID,
		arg.ExerciseID,
		arg.TotalAttempts,
		arg.SuccessfulAttempts,
		arg.TotalTypingTime,
		arg.TotalTypedChars,
	)
	var i ExerciseStat
	err := row.Scan(
		&i.UserID,
		&i.ExerciseID,
		&i.TotalAttempts,
		&i.SuccessfulAttempts,
		&i.TotalTypingTime,
		&i.TotalTypedChars,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateUserName = `-- name: UpdateUserName :one
UPDATE users
SET name = $1
WHERE user_id = $2
RETURNING user_id, name, evaluation_strategy, maximum_score, is_admin
`

type UpdateUserNameParams struct {
	Name   string
	UserID int64
}

func (q *Queries) UpdateUserName(ctx context.Context, arg *UpdateUserNameParams) (*User, error) {
	row := q.db.QueryRow(ctx, updateUserName, arg.Name, arg.UserID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Name,
		&i.EvaluationStrategy,
		&i.MaximumScore,
		&i.IsAdmin,
	)
	return &i, err
}

const upsertExerciseStat = `-- name: UpsertExerciseStat :one
INSERT INTO exercise_stats (user_id, exercise_id, total_attempts, successful_attempts, total_typing_time, total_typed_chars, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
ON CONFLICT (user_id, exercise_id) DO UPDATE SET
    total_attempts = exercise_stats.total_attempts + EXCLUDED.total_attempts,
    successful_attempts = exercise_stats.successful_attempts + EXCLUDED.successful_attempts,
    total_typing_time = exercise_stats.total_typing_time + EXCLUDED.total_typing_time,
    total_typed_chars = exercise_stats.total_typed_chars + EXCLUDED.total_typed_chars,
    updated_at = NOW()
RETURNING  user_id, exercise_id, total_attempts, successful_attempts, total_typing_time, total_typed_chars, created_at, updated_at
`

type UpsertExerciseStatParams struct {
	UserID             int64
	ExerciseID         int64
	TotalAttempts      int32
	SuccessfulAttempts int32
	TotalTypingTime    int64
	TotalTypedChars    int32
}

func (q *Queries) UpsertExerciseStat(ctx context.Context, arg *UpsertExerciseStatParams) (*ExerciseStat, error) {
	row := q.db.QueryRow(ctx, upsertExerciseStat,
		arg.UserID,
		arg.ExerciseID,
		arg.TotalAttempts,
		arg.SuccessfulAttempts,
		arg.TotalTypingTime,
		arg.TotalTypedChars,
	)
	var i ExerciseStat
	err := row.Scan(
		&i.UserID,
		&i.ExerciseID,
		&i.TotalAttempts,
		&i.SuccessfulAttempts,
		&i.TotalTypingTime,
		&i.TotalTypedChars,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
